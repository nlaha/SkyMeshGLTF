
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyffi.object_models &#8212; PyFFI 2.2.4.dev4 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PyFFI 2.2.4.dev4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pyffi.object_models</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyffi.object_models</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">:mod:`pyffi.object_models` --- File format description engines</span>
<span class="sd">==============================================================</span>

<span class="sd">.. warning::</span>

<span class="sd">   The documentation of this module is very incomplete.</span>

<span class="sd">This module bundles all file format object models. An object model</span>
<span class="sd">is a group of classes whose instances can hold the information</span>
<span class="sd">contained in a file whose format is described in a particular way</span>
<span class="sd">(xml, xsd, and possibly others).</span>

<span class="sd">..</span>
<span class="sd">  There is a strong distinction between types that contain very specific</span>
<span class="sd">  simple data (SimpleType) and more complex types that contain groups of</span>
<span class="sd">  simple data (ComplexType, with its descendants StructType for named</span>
<span class="sd">  lists of objects of different type and ArrayType for indexed lists of</span>
<span class="sd">  objects of the same type).</span>
<span class="sd">  </span>
<span class="sd">  The complex types are generic in that they can be instantiated using</span>
<span class="sd">  metadata (i.e. data describing the structure of the actual file data)</span>
<span class="sd">  from xml, xsd, or any other file format description.</span>
<span class="sd">  </span>
<span class="sd">  For the simple types there are specific classes implementing access to</span>
<span class="sd">  these data types. Typical implementations are present for integers,</span>
<span class="sd">  floats, strings, and so on. Some simple types may also be derived from</span>
<span class="sd">  already implemented simple types, if the metadata description allows</span>
<span class="sd">  this.</span>

<span class="sd">.. autoclass:: MetaFileFormat</span>
<span class="sd">   :show-inheritance:</span>
<span class="sd">   :members:</span>

<span class="sd">.. autoclass:: FileFormat</span>
<span class="sd">   :show-inheritance:</span>
<span class="sd">   :members:</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># ***** BEGIN LICENSE BLOCK *****</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2007-2012, Python File Format Interface</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions</span>
<span class="c1"># are met:</span>
<span class="c1">#</span>
<span class="c1">#    * Redistributions of source code must retain the above copyright</span>
<span class="c1">#      notice, this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1">#    * Redistributions in binary form must reproduce the above</span>
<span class="c1">#      copyright notice, this list of conditions and the following</span>
<span class="c1">#      disclaimer in the documentation and/or other materials provided</span>
<span class="c1">#      with the distribution.</span>
<span class="c1">#</span>
<span class="c1">#    * Neither the name of the Python File Format Interface</span>
<span class="c1">#      project nor the names of its contributors may be used to endorse</span>
<span class="c1">#      or promote products derived from this software without specific</span>
<span class="c1">#      prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="c1"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="c1"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</span>
<span class="c1"># FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE</span>
<span class="c1"># COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<span class="c1"># INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</span>
<span class="c1"># BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="c1"># LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="c1"># CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<span class="c1"># LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN</span>
<span class="c1"># ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="c1"># POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="c1"># ***** END LICENSE BLOCK *****</span>

<span class="kn">import</span> <span class="nn">codecs</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os.path</span> <span class="c1"># os.path.altsep</span>
<span class="kn">import</span> <span class="nn">re</span> <span class="c1"># compile</span>
<span class="kn">import</span> <span class="nn">sys</span> <span class="c1"># version_info</span>

<span class="kn">import</span> <span class="nn">pyffi.utils</span>
<span class="kn">import</span> <span class="nn">pyffi.utils.graph</span>


<div class="viewcode-block" id="MetaFileFormat"><a class="viewcode-back" href="../../pyffi/object_models.html#pyffi.object_models.MetaFileFormat">[docs]</a><span class="k">class</span> <span class="nc">MetaFileFormat</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This metaclass is an abstract base class for transforming</span>
<span class="sd">    a file format description into classes which can be directly used to</span>
<span class="sd">    manipulate files in this format.</span>

<span class="sd">    A file format is implemented as a particular class (a subclass of</span>
<span class="sd">    :class:`FileFormat`) with class members corresponding to different</span>
<span class="sd">    (bit)struct types, enum types, basic types, and aliases.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MetaFileFormat.openfile"><a class="viewcode-back" href="../../pyffi/object_models.html#pyffi.object_models.MetaFileFormat.openfile">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">openfile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">filepaths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find *filename* in given *filepaths*, and open it. Raises</span>
<span class="sd">        ``IOError`` if file cannot be opened.</span>

<span class="sd">        :param filename: The file to open.</span>
<span class="sd">        :type filename: ``str``</span>
<span class="sd">        :param filepaths: List of paths where to look for the file.</span>
<span class="sd">        :type filepaths: ``list`` of ``str``\ s</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">open_with_encoding</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">codecs</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">filepaths</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">open_with_encoding</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">filepath</span> <span class="ow">in</span> <span class="n">filepaths</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">filepath</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">open_with_encoding</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">filename</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; not found in any of the directories </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">filepaths</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="FileFormat"><a class="viewcode-back" href="../../pyffi/object_models.html#pyffi.object_models.FileFormat">[docs]</a><span class="k">class</span> <span class="nc">FileFormat</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class is the base class for all file formats. It implements</span>
<span class="sd">    a number of useful functions such as walking over directory trees</span>
<span class="sd">    (:meth:`walkData`) and a default attribute naming function</span>
<span class="sd">    (:meth:`name_attribute`).</span>
<span class="sd">    It also implements the base class for representing file data</span>
<span class="sd">    (:class:`FileFormat.Data`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">RE_FILENAME</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;Override this with a regular expression (the result of a ``re.compile``</span>
<span class="sd">    call) for the file extension of the format you are implementing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ARCHIVE_CLASSES</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="sd">&quot;&quot;&quot;Override this with a list of archive formats that may contain</span>
<span class="sd">    files of the format.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># precompiled regular expressions, used in name_parts</span>

    <span class="n">_RE_NAME_SEP</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;[_\W]+&#39;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Matches seperators for splitting names.&quot;&quot;&quot;</span>
    
    <span class="n">_RE_NAME_DIGITS</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;([0-9]+)|([a-zA-Z]+)&#39;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Matches digits or characters for splitting names.&quot;&quot;&quot;</span>

    <span class="n">_RE_NAME_CAMEL</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;([A-Z][a-z]*)|([a-z]+)&#39;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Finds components of camelCase and CamelCase names.&quot;&quot;&quot;</span>

    <span class="n">_RE_NAME_LC</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;[a-z]&#39;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Matches a lower case character.&quot;&quot;&quot;</span>

    <span class="n">_RE_NAME_UC</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;[A-Z]&#39;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Matches an upper case character.&quot;&quot;&quot;</span>

    <span class="c1"># override this with the data instance for this format</span>
<div class="viewcode-block" id="FileFormat.Data"><a class="viewcode-back" href="../../pyffi/object_models.html#pyffi.object_models.FileFormat.Data">[docs]</a>    <span class="k">class</span> <span class="nc">Data</span><span class="p">(</span><span class="n">pyffi</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">GlobalNode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Base class for representing data in a particular format.</span>
<span class="sd">        Override this class to implement reading and writing.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_byte_order</span> <span class="o">=</span> <span class="s1">&#39;&lt;&#39;</span>
        <span class="sd">&quot;&quot;&quot;Set to &#39;&lt;&#39; for little-endian, and &#39;&gt;&#39; for big-endian.&quot;&quot;&quot;</span>

        <span class="n">version</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Version of the data.&quot;&quot;&quot;</span>

        <span class="n">user_version</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;User version (additional version field) of the data.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="FileFormat.Data.inspect"><a class="viewcode-back" href="../../pyffi/object_models.html#pyffi.object_models.FileFormat.Data.inspect">[docs]</a>        <span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Quickly checks whether the stream appears to contain</span>
<span class="sd">            data of a particular format. Resets stream to original position.</span>
<span class="sd">            Call this function if you simply wish to check that a file is</span>
<span class="sd">            of a particular format without having to parse it completely.</span>

<span class="sd">            Override this method.</span>

<span class="sd">            :param stream: The file to inspect.</span>
<span class="sd">            :type stream: file</span>
<span class="sd">            :return: ``True`` if stream is of particular format, ``False``</span>
<span class="sd">                otherwise.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="FileFormat.Data.read"><a class="viewcode-back" href="../../pyffi/object_models.html#pyffi.object_models.FileFormat.Data.read">[docs]</a>        <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Read data of particular format from stream.</span>
<span class="sd">            Override this method.</span>

<span class="sd">            :param stream: The file to read from.</span>
<span class="sd">            :type stream: ``file``</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="FileFormat.Data.write"><a class="viewcode-back" href="../../pyffi/object_models.html#pyffi.object_models.FileFormat.Data.write">[docs]</a>        <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Write data of particular format to stream.</span>
<span class="sd">            Override this method.</span>

<span class="sd">            :param stream: The file to write to.</span>
<span class="sd">            :type stream: ``file``</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span></div></div>

<div class="viewcode-block" id="FileFormat.version_number"><a class="viewcode-back" href="../../pyffi/object_models.html#pyffi.object_models.FileFormat.version_number">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">version_number</span><span class="p">(</span><span class="n">version_str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts version string into an integer.</span>
<span class="sd">        This default implementation simply returns zero at all times,</span>
<span class="sd">        and works for formats that are not versioned.</span>

<span class="sd">        Override for versioned formats.</span>

<span class="sd">        :param version_str: The version string.</span>
<span class="sd">        :type version_str: ``str``</span>
<span class="sd">        :return: A version integer. A negative number denotes an</span>
<span class="sd">            invalid version.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="FileFormat.name_parts"><a class="viewcode-back" href="../../pyffi/object_models.html#pyffi.object_models.FileFormat.name_parts">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">name_parts</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Intelligently split a name into parts:</span>

<span class="sd">        * first, split at non-alphanumeric characters</span>
<span class="sd">        * next, seperate digits from characters</span>
<span class="sd">        * finally, if some part has mixed case, it must be</span>
<span class="sd">          camel case so split it further at upper case characters</span>

<span class="sd">        &gt;&gt;&gt; FileFormat.name_parts(&quot;hello_world&quot;)</span>
<span class="sd">        [&#39;hello&#39;, &#39;world&#39;]</span>
<span class="sd">        &gt;&gt;&gt; FileFormat.name_parts(&quot;HELLO_WORLD&quot;)</span>
<span class="sd">        [&#39;HELLO&#39;, &#39;WORLD&#39;]</span>
<span class="sd">        &gt;&gt;&gt; FileFormat.name_parts(&quot;HelloWorld&quot;)</span>
<span class="sd">        [&#39;Hello&#39;, &#39;World&#39;]</span>
<span class="sd">        &gt;&gt;&gt; FileFormat.name_parts(&quot;helloWorld&quot;)</span>
<span class="sd">        [&#39;hello&#39;, &#39;World&#39;]</span>
<span class="sd">        &gt;&gt;&gt; FileFormat.name_parts(&quot;xs:NMTOKEN&quot;)</span>
<span class="sd">        [&#39;xs&#39;, &#39;NMTOKEN&#39;]</span>
<span class="sd">        &gt;&gt;&gt; FileFormat.name_parts(&quot;xs:NCName&quot;)</span>
<span class="sd">        [&#39;xs&#39;, &#39;N&#39;, &#39;C&#39;, &#39;Name&#39;]</span>
<span class="sd">        &gt;&gt;&gt; FileFormat.name_parts(&#39;this IS a sillyNAME&#39;)</span>
<span class="sd">        [&#39;this&#39;, &#39;IS&#39;, &#39;a&#39;, &#39;silly&#39;, &#39;N&#39;, &#39;A&#39;, &#39;M&#39;, &#39;E&#39;]</span>
<span class="sd">        &gt;&gt;&gt; FileFormat.name_parts(&#39;tHis is A Silly naME&#39;)</span>
<span class="sd">        [&#39;t&#39;, &#39;His&#39;, &#39;is&#39;, &#39;A&#39;, &#39;Silly&#39;, &#39;na&#39;, &#39;M&#39;, &#39;E&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># str(name) converts name to string in case it is a py2k</span>
        <span class="c1"># unicode string</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># separate at symbols</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_RE_NAME_SEP</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># seperate digits</span>
        <span class="n">newparts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">part_groups</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_RE_NAME_DIGITS</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">part</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">part_groups</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">group</span><span class="p">:</span>
                        <span class="n">newparts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                        <span class="k">break</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">newparts</span>
        <span class="c1"># separate at upper case characters for CamelCase and camelCase words</span>
        <span class="n">newparts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_RE_NAME_LC</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_RE_NAME_UC</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">part</span><span class="p">):</span>
                <span class="c1"># find the camel bumps</span>
                <span class="k">for</span> <span class="n">part_groups</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_RE_NAME_CAMEL</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">part</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">part_groups</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">group</span><span class="p">:</span>
                            <span class="n">newparts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                            <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newparts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">newparts</span>
        <span class="c1"># return result</span>
        <span class="k">return</span> <span class="n">parts</span></div>

<div class="viewcode-block" id="FileFormat.name_attribute"><a class="viewcode-back" href="../../pyffi/object_models.html#pyffi.object_models.FileFormat.name_attribute">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">name_attribute</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts an attribute name, as in the description file,</span>
<span class="sd">        into a name usable by python.</span>

<span class="sd">        :param name: The attribute name.</span>
<span class="sd">        :type name: ``str``</span>
<span class="sd">        :return: Reformatted attribute name, useable by python.</span>

<span class="sd">        &gt;&gt;&gt; FileFormat.name_attribute(&#39;tHis is A Silly naME&#39;)</span>
<span class="sd">        &#39;t_his_is_a_silly_na_m_e&#39;</span>
<span class="sd">        &gt;&gt;&gt; FileFormat.name_attribute(&#39;Test:Something&#39;)</span>
<span class="sd">        &#39;test_something&#39;</span>
<span class="sd">        &gt;&gt;&gt; FileFormat.name_attribute(&#39;unknown?&#39;)</span>
<span class="sd">        &#39;unknown&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">name_parts</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

<div class="viewcode-block" id="FileFormat.name_class"><a class="viewcode-back" href="../../pyffi/object_models.html#pyffi.object_models.FileFormat.name_class">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">name_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a class name, as in the xsd file, into a name usable</span>
<span class="sd">        by python.</span>

<span class="sd">        :param name: The class name.</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :return: Reformatted class name, useable by python.</span>

<span class="sd">        &gt;&gt;&gt; FileFormat.name_class(&#39;this IS a sillyNAME&#39;)</span>
<span class="sd">        &#39;ThisIsASillyNAME&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
                       <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">name_parts</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

<div class="viewcode-block" id="FileFormat.walkData"><a class="viewcode-back" href="../../pyffi/object_models.html#pyffi.object_models.FileFormat.walkData">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">walkData</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">topdown</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;rb&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A generator which yields the data of all files in</span>
<span class="sd">        directory top whose filename matches the regular expression</span>
<span class="sd">        :attr:`RE_FILENAME`. The argument top can also be a file instead of a</span>
<span class="sd">        directory. Errors coming from os.walk are ignored.</span>

<span class="sd">        Note that the caller is not responsible for closing the stream.</span>

<span class="sd">        This function is for instance used by :mod:`pyffi.spells` to implement</span>
<span class="sd">        modifying a file after reading and parsing.</span>

<span class="sd">        :param top: The top folder.</span>
<span class="sd">        :type top: ``str``</span>
<span class="sd">        :param topdown: Determines whether subdirectories should be iterated</span>
<span class="sd">            over first.</span>
<span class="sd">        :type topdown: ``bool``</span>
<span class="sd">        :param mode: The mode in which to open files.</span>
<span class="sd">        :type mode: ``str``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># now walk over all these files in directory top</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">pyffi</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">topdown</span><span class="p">,</span> <span class="n">onerror</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">re_filename</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">RE_FILENAME</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># return data for the stream</span>
                <span class="c1"># the caller can call data.read(stream),</span>
                <span class="c1"># or data.inspect(stream), etc.</span>
                <span class="k">yield</span> <span class="n">stream</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">Data</span><span class="p">()</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="FileFormat.walk"><a class="viewcode-back" href="../../pyffi/object_models.html#pyffi.object_models.FileFormat.walk">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">walk</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">topdown</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;rb&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A generator which yields all files in</span>
<span class="sd">        directory top whose filename matches the regular expression</span>
<span class="sd">        :attr:`RE_FILENAME`. The argument top can also be a file instead of a</span>
<span class="sd">        directory. Errors coming from os.walk are ignored.</span>

<span class="sd">        Note that the caller is not responsible for closing the stream.</span>

<span class="sd">        This function is for instance used by :mod:`pyffi.spells` to implement</span>
<span class="sd">        modifying a file after reading and parsing.</span>

<span class="sd">        :param top: The top folder.</span>
<span class="sd">        :type top: ``str``</span>
<span class="sd">        :param topdown: Determines whether subdirectories should be iterated</span>
<span class="sd">            over first.</span>
<span class="sd">        :type topdown: ``bool``</span>
<span class="sd">        :param mode: The mode in which to open files.</span>
<span class="sd">        :type mode: ``str``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># now walk over all these files in directory top</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">pyffi</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">topdown</span><span class="p">,</span> <span class="n">onerror</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">re_filename</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">RE_FILENAME</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">stream</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div></div>

<span class="k">class</span> <span class="nc">ArchiveFileFormat</span><span class="p">(</span><span class="n">FileFormat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class is the base class for all archive file formats. It</span>
<span class="sd">    implements incremental reading and writing of archive files.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">Data</span><span class="p">(</span><span class="n">FileFormat</span><span class="o">.</span><span class="n">Data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Base class for representing archive data.</span>
<span class="sd">        Override this class to implement incremental reading and writing.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_stream</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;The file stream associated with the archive.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fileobj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Sets _stream and _mode.&quot;&quot;&quot;</span>
            <span class="c1"># at least:</span>
            <span class="c1">#self._stream = fileobj if fileobj else open(name, mode)</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="k">def</span> <span class="nf">get_members</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="k">def</span> <span class="nf">set_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># at least:</span>
            <span class="c1">#self._stream.close()</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span> <span class="o">==</span> <span class="n">stream</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot write back to the same stream&quot;</span><span class="p">)</span>
            <span class="c1"># get all members from the old stream</span>
            <span class="n">members</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_members</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">fileobj</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>
            <span class="c1"># set all members to the new stream</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_members</span><span class="p">(</span><span class="n">members</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ArchiveMember</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;Temporary file stream which contains the extracted data.&quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;Name of the file as recorded in the archive.&quot;&quot;&quot;</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PyFFI 2.2.4.dev4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pyffi.object_models</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2019, NifTools.
      Last updated on Jan 26, 2021.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>
  </body>
</html>